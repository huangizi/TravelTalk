{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport React, { useEffect, useImperativeHandle, useRef, useMemo, useState } from 'react';\nimport { getValidScrollTop, getCompareItemRelativeTop, getItemAbsoluteTop, getItemRelativeTop, getNodeHeight, getRangeIndex, getScrollPercentage, GHOST_ITEM_KEY, getLongestItemIndex, getLocationItem } from './utils/itemUtil';\nimport { raf, caf } from '../../_util/raf';\nimport { isNumber } from '../../_util/is';\nimport usePrevious from '../../_util/hooks/usePrevious';\nimport { findListDiffIndex, getIndexByStartLoc } from './utils/algorithmUtil';\nimport Filler from './Filler';\nimport useStateWithPromise from '../../_util/hooks/useStateWithPromise';\nimport useIsFirstRender from '../../_util/hooks/useIsFirstRender';\nimport useForceUpdate from '../../_util/hooks/useForceUpdate';\nimport ResizeObserver from '../../_util/resizeObserver';\nimport useIsomorphicLayoutEffect from '../../_util/hooks/useIsomorphicLayoutEffect';\n// height of the virtual element, used to calculate total height of the virtual list\nvar DEFAULT_VIRTUAL_ITEM_HEIGHT = 32;\nvar KEY_VIRTUAL_ITEM_HEIGHT = \"__virtual_item_height_\" + Math.random().toFixed(5).slice(2);\n// after collecting the real height of the first screen element, calculate the virtual ItemHeight to trigger list re-rendering\nvar useComputeVirtualItemHeight = function (refItemHeightMap) {\n  var forceUpdate = useForceUpdate();\n  var heightMap = refItemHeightMap.current;\n  useEffect(function () {\n    // virtual item height should be static as possible, otherwise it is easy to cause jitter\n    if (Object.keys(heightMap).length && !heightMap[KEY_VIRTUAL_ITEM_HEIGHT]) {\n      heightMap[KEY_VIRTUAL_ITEM_HEIGHT] = Object.entries(heightMap).reduce(function (sum, _a, currentIndex, array) {\n        var _b = __read(_a, 2),\n          currentHeight = _b[1];\n        var nextSum = sum + currentHeight;\n        return currentIndex === array.length - 1 ? Math.round(nextSum / array.length) : nextSum;\n      }, 0);\n      forceUpdate();\n    }\n  }, [Object.keys(heightMap).length]);\n};\n// cache the constructed results of child nodes to avoid redrawing of child nodes caused by re-construction during drawing\nvar useCacheChildrenNodes = function (children) {\n  var refCacheMap = useRef({});\n  var refPrevChildren = useRef(children);\n  useEffect(function () {\n    refPrevChildren.current = children;\n  }, [children]);\n  // children change means state of parent component is updated, so clear cache\n  if (children !== refPrevChildren.current) {\n    refCacheMap.current = {};\n  }\n  return function (item, index, props) {\n    if (!refCacheMap.current.hasOwnProperty(index)) {\n      refCacheMap.current[index] = children(item, index, props);\n    }\n    return refCacheMap.current[index];\n  };\n};\nvar VirtualList = React.forwardRef(function (props, ref) {\n  var style = props.style,\n    className = props.className,\n    children = props.children,\n    _a = props.data,\n    data = _a === void 0 ? [] : _a,\n    itemKey = props.itemKey,\n    _b = props.threshold,\n    threshold = _b === void 0 ? 100 : _b,\n    _c = props.wrapper,\n    WrapperTagName = _c === void 0 ? 'div' : _c,\n    _d = props.height,\n    propHeight = _d === void 0 ? '100%' : _d,\n    _e = props.isStaticItemHeight,\n    isStaticItemHeight = _e === void 0 ? true : _e,\n    propItemHeight = props.itemHeight,\n    measureLongestItem = props.measureLongestItem,\n    scrollOptions = props.scrollOptions,\n    onScroll = props.onScroll,\n    _f = props.needFiller,\n    needFiller = _f === void 0 ? true : _f,\n    outerStyle = props.outerStyle,\n    restProps = __rest(props, [\"style\", \"className\", \"children\", \"data\", \"itemKey\", \"threshold\", \"wrapper\", \"height\", \"isStaticItemHeight\", \"itemHeight\", \"measureLongestItem\", \"scrollOptions\", \"onScroll\", \"needFiller\", \"outerStyle\"]);\n  // Compatible with setting the height of the list through style.maxHeight\n  var styleListMaxHeight = style && style.maxHeight || propHeight;\n  var refItemHeightMap = useRef({});\n  var _g = __read(useState(200), 2),\n    stateHeight = _g[0],\n    setStateHeight = _g[1];\n  var renderChild = useCacheChildrenNodes(children);\n  useComputeVirtualItemHeight(refItemHeightMap);\n  // Elements with the same height, the height of the item is based on the first rendering\n  var itemCount = data.length;\n  var itemHeight = propItemHeight || refItemHeightMap.current[KEY_VIRTUAL_ITEM_HEIGHT] || DEFAULT_VIRTUAL_ITEM_HEIGHT;\n  var viewportHeight = isNumber(styleListMaxHeight) ? styleListMaxHeight : stateHeight;\n  var itemCountVisible = Math.ceil(viewportHeight / itemHeight);\n  var itemTotalHeight = itemHeight * itemCount;\n  var isVirtual = threshold !== null && itemCount >= threshold && itemTotalHeight > viewportHeight;\n  var refList = useRef(null);\n  var refRafId = useRef(null);\n  var refLockScroll = useRef(false);\n  var refIsVirtual = useRef(isVirtual);\n  // The paddingTop of the record scrolling list is used to correct the scrolling distance\n  var scrollListPadding = useMemo(function () {\n    if (refList.current) {\n      var getPadding = function (property) {\n        return +window.getComputedStyle(refList.current)[property].replace(/\\D/g, '');\n      };\n      return {\n        top: getPadding('paddingTop'),\n        bottom: getPadding('paddingBottom')\n      };\n    }\n    return {\n      top: 0,\n      bottom: 0\n    };\n  }, [refList.current]);\n  var _h = __read(useStateWithPromise({\n      // measure status\n      status: 'NONE',\n      // render range info\n      startIndex: 0,\n      endIndex: 0,\n      itemIndex: 0,\n      itemOffsetPtg: 0,\n      // scroll info\n      startItemTop: 0,\n      scrollTop: 0\n    }), 2),\n    state = _h[0],\n    setState = _h[1];\n  var prevData = usePrevious(data) || [];\n  var isFirstRender = useIsFirstRender();\n  var getItemKey = function (item, index) {\n    return typeof itemKey === 'function' ? itemKey(item, index) : typeof itemKey === 'string' ? item[itemKey] : item.key || index;\n  };\n  var getItemKeyByIndex = function (index, items) {\n    if (items === void 0) {\n      items = data;\n    }\n    if (index === items.length) {\n      return GHOST_ITEM_KEY;\n    }\n    var item = items[index];\n    return item !== undefined ? getItemKey(item, index) : null;\n  };\n  var getCachedItemHeight = function (key) {\n    return refItemHeightMap.current[key] || itemHeight;\n  };\n  var internalScrollTo = function (relativeScroll) {\n    var compareItemIndex = relativeScroll.itemIndex,\n      compareItemRelativeTop = relativeScroll.relativeTop;\n    var _a = refList.current,\n      scrollHeight = _a.scrollHeight,\n      clientHeight = _a.clientHeight;\n    var originScrollTop = state.scrollTop;\n    var maxScrollTop = scrollHeight - clientHeight;\n    var bestSimilarity = Number.MAX_VALUE;\n    var bestScrollTop = null;\n    var bestItemIndex = null;\n    var bestItemOffsetPtg = null;\n    var bestStartIndex = null;\n    var bestEndIndex = null;\n    var missSimilarity = 0;\n    for (var i = 0; i < maxScrollTop; i++) {\n      var scrollTop = getIndexByStartLoc(0, maxScrollTop, originScrollTop, i);\n      var scrollPtg = getScrollPercentage({\n        scrollTop: scrollTop,\n        scrollHeight: scrollHeight,\n        clientHeight: clientHeight\n      });\n      var _b = getRangeIndex(scrollPtg, itemCount, itemCountVisible),\n        itemIndex = _b.itemIndex,\n        itemOffsetPtg = _b.itemOffsetPtg,\n        startIndex = _b.startIndex,\n        endIndex = _b.endIndex;\n      if (startIndex <= compareItemIndex && compareItemIndex <= endIndex) {\n        var locatedItemRelativeTop = getItemRelativeTop({\n          itemHeight: getCachedItemHeight(getItemKeyByIndex(itemIndex)),\n          itemOffsetPtg: itemOffsetPtg,\n          clientHeight: clientHeight,\n          scrollPtg: scrollPtg\n        });\n        var compareItemTop = getCompareItemRelativeTop({\n          locatedItemRelativeTop: locatedItemRelativeTop,\n          locatedItemIndex: itemIndex,\n          compareItemIndex: compareItemIndex,\n          startIndex: startIndex,\n          endIndex: endIndex,\n          itemHeight: itemHeight,\n          getItemKey: getItemKeyByIndex,\n          itemElementHeights: refItemHeightMap.current\n        });\n        var similarity = Math.abs(compareItemTop - compareItemRelativeTop);\n        if (similarity < bestSimilarity) {\n          bestSimilarity = similarity;\n          bestScrollTop = scrollTop;\n          bestItemIndex = itemIndex;\n          bestItemOffsetPtg = itemOffsetPtg;\n          bestStartIndex = startIndex;\n          bestEndIndex = endIndex;\n          missSimilarity = 0;\n        } else {\n          missSimilarity += 1;\n        }\n      }\n      if (missSimilarity > 10) {\n        break;\n      }\n    }\n    if (bestScrollTop !== null) {\n      refLockScroll.current = true;\n      refList.current.scrollTop = bestScrollTop;\n      setState(__assign(__assign({}, state), {\n        status: 'MEASURE_START',\n        scrollTop: bestScrollTop,\n        itemIndex: bestItemIndex,\n        itemOffsetPtg: bestItemOffsetPtg,\n        startIndex: bestStartIndex,\n        endIndex: bestEndIndex\n      }));\n    }\n    refRafId.current = raf(function () {\n      refLockScroll.current = false;\n    });\n  };\n  // Record the current element position when the real list is scrolled, and ensure that the position is correct after switching to the virtual list\n  var rawListScrollHandler = function (event) {\n    var _a = refList.current,\n      rawScrollTop = _a.scrollTop,\n      clientHeight = _a.clientHeight,\n      scrollHeight = _a.scrollHeight;\n    var scrollTop = getValidScrollTop(rawScrollTop, scrollHeight - clientHeight);\n    var scrollPtg = getScrollPercentage({\n      scrollTop: scrollTop,\n      clientHeight: clientHeight,\n      scrollHeight: scrollHeight\n    });\n    var _b = getLocationItem(scrollPtg, itemCount),\n      index = _b.index,\n      offsetPtg = _b.offsetPtg;\n    setState(__assign(__assign({}, state), {\n      scrollTop: scrollTop,\n      itemIndex: index,\n      itemOffsetPtg: offsetPtg\n    }));\n    event && onScroll && onScroll(event);\n  };\n  // Modify the state and recalculate the position in the next render\n  var virtualListScrollHandler = function (event, isInit) {\n    if (isInit === void 0) {\n      isInit = false;\n    }\n    // Do NOT use refList.current.scrollHeight\n    // We should use Filler's height as total scroll height\n    // Filler's translate style may make refList.current.scrollHeight larger than Filler's height\n    var scrollHeight = itemTotalHeight;\n    var _a = refList.current,\n      rawScrollTop = _a.scrollTop,\n      clientHeight = _a.clientHeight;\n    var scrollTop = getValidScrollTop(rawScrollTop, scrollHeight - clientHeight);\n    // Prevent jitter\n    if (!isInit && (scrollTop === state.scrollTop || refLockScroll.current)) {\n      return;\n    }\n    var scrollPtg = getScrollPercentage({\n      scrollTop: scrollTop,\n      clientHeight: clientHeight,\n      scrollHeight: scrollHeight\n    });\n    var _b = getRangeIndex(scrollPtg, itemCount, itemCountVisible),\n      itemIndex = _b.itemIndex,\n      itemOffsetPtg = _b.itemOffsetPtg,\n      startIndex = _b.startIndex,\n      endIndex = _b.endIndex;\n    setState(__assign(__assign({}, state), {\n      scrollTop: scrollTop,\n      itemIndex: itemIndex,\n      itemOffsetPtg: itemOffsetPtg,\n      startIndex: startIndex,\n      endIndex: endIndex,\n      status: 'MEASURE_START'\n    }));\n    event && onScroll && onScroll(event);\n  };\n  useEffect(function () {\n    return function () {\n      refRafId.current && caf(refRafId.current);\n    };\n  }, []);\n  // rerender when the number of visible elements changes\n  useEffect(function () {\n    if (refList.current) {\n      if (isFirstRender) {\n        refList.current.scrollTop = 0;\n      }\n      virtualListScrollHandler(null, true);\n    }\n  }, [itemCountVisible]);\n  // Handle additions and deletions of list items or switching the virtual state\n  useEffect(function () {\n    var changedItemIndex = null;\n    var switchTo = refIsVirtual.current !== isVirtual ? isVirtual ? 'virtual' : 'raw' : '';\n    refIsVirtual.current = isVirtual;\n    if (viewportHeight && prevData.length !== data.length) {\n      var diff = findListDiffIndex(prevData, data, getItemKey);\n      changedItemIndex = diff ? diff.index : null;\n    }\n    // No need to correct the position when the number of elements in the real list changes\n    if (switchTo || isVirtual && changedItemIndex) {\n      var clientHeight = refList.current.clientHeight;\n      var locatedItemRelativeTop = getItemRelativeTop({\n        itemHeight: getCachedItemHeight(getItemKeyByIndex(state.itemIndex, prevData)),\n        itemOffsetPtg: state.itemOffsetPtg,\n        scrollPtg: getScrollPercentage({\n          scrollTop: state.scrollTop,\n          scrollHeight: prevData.length * itemHeight,\n          clientHeight: clientHeight\n        }),\n        clientHeight: clientHeight\n      });\n      if (switchTo === 'raw') {\n        var rawTop = locatedItemRelativeTop;\n        for (var index = 0; index < state.itemIndex; index++) {\n          rawTop -= getCachedItemHeight(getItemKeyByIndex(index));\n        }\n        refList.current.scrollTop = -rawTop;\n        refLockScroll.current = true;\n        refRafId.current = raf(function () {\n          refLockScroll.current = false;\n        });\n      } else {\n        internalScrollTo({\n          itemIndex: state.itemIndex,\n          relativeTop: locatedItemRelativeTop\n        });\n      }\n    }\n  }, [data, isVirtual]);\n  useIsomorphicLayoutEffect(function () {\n    if (state.status === 'MEASURE_START') {\n      var _a = refList.current,\n        scrollTop = _a.scrollTop,\n        scrollHeight = _a.scrollHeight,\n        clientHeight = _a.clientHeight;\n      var scrollPtg = getScrollPercentage({\n        scrollTop: scrollTop,\n        scrollHeight: scrollHeight,\n        clientHeight: clientHeight\n      });\n      // Calculate the top value of the first rendering element\n      var startItemTop = getItemAbsoluteTop({\n        scrollPtg: scrollPtg,\n        clientHeight: clientHeight,\n        scrollTop: scrollTop - (scrollListPadding.top + scrollListPadding.bottom) * scrollPtg,\n        itemHeight: getCachedItemHeight(getItemKeyByIndex(state.itemIndex)),\n        itemOffsetPtg: state.itemOffsetPtg\n      });\n      for (var index = state.itemIndex - 1; index >= state.startIndex; index--) {\n        startItemTop -= getCachedItemHeight(getItemKeyByIndex(index));\n      }\n      setState(__assign(__assign({}, state), {\n        startItemTop: startItemTop,\n        status: 'MEASURE_DONE'\n      }));\n    }\n  }, [state]);\n  useImperativeHandle(ref, function () {\n    return {\n      dom: refList.current,\n      // Scroll to a certain height or an element\n      scrollTo: function (arg) {\n        refRafId.current && caf(refRafId.current);\n        refRafId.current = raf(function () {\n          var _a;\n          if (typeof arg === 'number') {\n            refList.current.scrollTop = arg;\n            return;\n          }\n          var index = 'index' in arg ? arg.index : 'key' in arg ? data.findIndex(function (item, index) {\n            return getItemKey(item, index) === arg.key;\n          }) : 0;\n          var item = data[index];\n          if (!item) {\n            return;\n          }\n          var align = typeof arg === 'object' && ((_a = arg.options) === null || _a === void 0 ? void 0 : _a.block) ? arg.options.block : (scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.block) || 'nearest';\n          var _b = refList.current,\n            clientHeight = _b.clientHeight,\n            scrollTop = _b.scrollTop;\n          if (isVirtual && !isStaticItemHeight) {\n            if (align === 'nearest') {\n              var itemIndex = state.itemIndex,\n                itemOffsetPtg = state.itemOffsetPtg;\n              if (Math.abs(itemIndex - index) < itemCountVisible) {\n                var itemTop = getItemRelativeTop({\n                  itemHeight: getCachedItemHeight(getItemKeyByIndex(itemIndex)),\n                  itemOffsetPtg: itemOffsetPtg,\n                  clientHeight: clientHeight,\n                  scrollPtg: getScrollPercentage(refList.current)\n                });\n                if (index < itemIndex) {\n                  for (var i = index; i < itemIndex; i++) {\n                    itemTop -= getCachedItemHeight(getItemKeyByIndex(i));\n                  }\n                } else {\n                  for (var i = itemIndex; i < index; i++) {\n                    itemTop += getCachedItemHeight(getItemKeyByIndex(i));\n                  }\n                }\n                // When the target element is within the field of view, exit directly\n                if (itemTop < 0 || itemTop > clientHeight) {\n                  align = itemTop < 0 ? 'start' : 'end';\n                } else {\n                  return;\n                }\n              } else {\n                align = index < itemIndex ? 'start' : 'end';\n              }\n            }\n            setState(__assign(__assign({}, state), {\n              startIndex: Math.max(0, index - itemCountVisible),\n              endIndex: Math.min(itemCount - 1, index + itemCountVisible)\n            })).then(function () {\n              var itemHeight = getCachedItemHeight(getItemKey(item, index));\n              internalScrollTo({\n                itemIndex: index,\n                relativeTop: align === 'start' ? 0 : (clientHeight - itemHeight) / (align === 'center' ? 2 : 1)\n              });\n            });\n          } else {\n            var indexItemHeight = getCachedItemHeight(getItemKeyByIndex(index));\n            var itemTop = 0;\n            for (var i = 0; i < index; i++) {\n              itemTop += getCachedItemHeight(getItemKeyByIndex(i));\n            }\n            var itemBottom = itemTop + indexItemHeight;\n            var itemMiddle = itemTop + indexItemHeight / 2;\n            // If item is visible, skip scrolling\n            if (itemMiddle > scrollTop && itemMiddle < clientHeight + scrollTop) {\n              return;\n            }\n            if (align === 'nearest') {\n              if (itemTop < scrollTop) {\n                align = 'start';\n              } else if (itemBottom > scrollTop + clientHeight) {\n                align = 'end';\n              }\n            }\n            var viewportHeight_1 = clientHeight - indexItemHeight;\n            refList.current.scrollTop = itemTop - (align === 'start' ? 0 : viewportHeight_1 / (align === 'center' ? 2 : 1));\n          }\n        });\n      }\n    };\n  }, [data, itemHeight, state]);\n  var renderChildren = function (list, startIndex) {\n    return list.map(function (item, index) {\n      var originIndex = startIndex + index;\n      var node = renderChild(item, originIndex, {\n        style: {}\n      });\n      var key = getItemKey(item, originIndex);\n      return React.cloneElement(node, {\n        key: key,\n        ref: function (ele) {\n          var heightMap = refItemHeightMap.current;\n          // Minimize the measurement of element height as much as possible to avoid frequent triggering of browser reflow\n          // Method getNodeHeight get the clientHeight from the DOM referred by React ref. If result is wrong, check the ref of this element\n          if (ele && state.status === 'MEASURE_START' && (!isStaticItemHeight || heightMap[key] === undefined)) {\n            if (isStaticItemHeight) {\n              if (!heightMap[KEY_VIRTUAL_ITEM_HEIGHT]) {\n                heightMap[KEY_VIRTUAL_ITEM_HEIGHT] = getNodeHeight(ele, true);\n              }\n              heightMap[key] = heightMap[KEY_VIRTUAL_ITEM_HEIGHT];\n            } else {\n              heightMap[key] = getNodeHeight(ele, true);\n            }\n          }\n        }\n      });\n    });\n  };\n  // Render the widest element to provide the maximum width of the container initially\n  var refLongestItemIndex = useRef(null);\n  // Don't add `renderChild` to the array dependency, it will change every time when rerender\n  useEffect(function () {\n    refLongestItemIndex.current = null;\n  }, [data]);\n  var renderLongestItem = function () {\n    if (measureLongestItem) {\n      var index = refLongestItemIndex.current === null ? getLongestItemIndex(data) : refLongestItemIndex.current;\n      var item = data[index];\n      refLongestItemIndex.current = index;\n      return item ? React.createElement(\"div\", {\n        style: {\n          height: 1,\n          overflow: 'hidden',\n          opacity: 0\n        }\n      }, renderChild(item, index, {\n        style: {}\n      })) : null;\n    }\n    return null;\n  };\n  return React.createElement(ResizeObserver, {\n    onResize: function () {\n      if (refList.current && !isNumber(styleListMaxHeight)) {\n        var clientHeight = refList.current.clientHeight;\n        setStateHeight(clientHeight);\n      }\n    }\n  }, React.createElement(WrapperTagName, __assign({\n    ref: refList,\n    style: __assign(__assign({\n      overflowY: 'auto',\n      overflowAnchor: 'none'\n    }, style), {\n      maxHeight: styleListMaxHeight\n    }),\n    className: className,\n    onScroll: isVirtual ? virtualListScrollHandler : rawListScrollHandler\n  }, restProps), isVirtual ? React.createElement(React.Fragment, null, React.createElement(Filler, {\n    height: itemTotalHeight,\n    offset: state.status === 'MEASURE_DONE' ? state.startItemTop : 0,\n    outerStyle: outerStyle\n  }, renderChildren(data.slice(state.startIndex, state.endIndex + 1), state.startIndex)), renderLongestItem()) : needFiller ? React.createElement(Filler, {\n    height: viewportHeight\n  }, renderChildren(data, 0)) : renderChildren(data, 0)));\n});\nVirtualList.displayName = 'VirtualList';\nexport default VirtualList;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__rest","e","indexOf","getOwnPropertySymbols","propertyIsEnumerable","__read","o","m","Symbol","iterator","r","ar","next","done","push","value","error","React","useEffect","useImperativeHandle","useRef","useMemo","useState","getValidScrollTop","getCompareItemRelativeTop","getItemAbsoluteTop","getItemRelativeTop","getNodeHeight","getRangeIndex","getScrollPercentage","GHOST_ITEM_KEY","getLongestItemIndex","getLocationItem","raf","caf","isNumber","usePrevious","findListDiffIndex","getIndexByStartLoc","Filler","useStateWithPromise","useIsFirstRender","useForceUpdate","ResizeObserver","useIsomorphicLayoutEffect","DEFAULT_VIRTUAL_ITEM_HEIGHT","KEY_VIRTUAL_ITEM_HEIGHT","Math","random","toFixed","slice","useComputeVirtualItemHeight","refItemHeightMap","forceUpdate","heightMap","current","keys","entries","reduce","sum","_a","currentIndex","array","_b","currentHeight","nextSum","round","useCacheChildrenNodes","children","refCacheMap","refPrevChildren","item","index","props","VirtualList","forwardRef","ref","style","className","data","itemKey","threshold","_c","wrapper","WrapperTagName","_d","height","propHeight","_e","isStaticItemHeight","propItemHeight","itemHeight","measureLongestItem","scrollOptions","onScroll","_f","needFiller","outerStyle","restProps","styleListMaxHeight","maxHeight","_g","stateHeight","setStateHeight","renderChild","itemCount","viewportHeight","itemCountVisible","ceil","itemTotalHeight","isVirtual","refList","refRafId","refLockScroll","refIsVirtual","scrollListPadding","getPadding","property","window","getComputedStyle","replace","top","bottom","_h","status","startIndex","endIndex","itemIndex","itemOffsetPtg","startItemTop","scrollTop","state","setState","prevData","isFirstRender","getItemKey","key","getItemKeyByIndex","items","undefined","getCachedItemHeight","internalScrollTo","relativeScroll","compareItemIndex","compareItemRelativeTop","relativeTop","scrollHeight","clientHeight","originScrollTop","maxScrollTop","bestSimilarity","Number","MAX_VALUE","bestScrollTop","bestItemIndex","bestItemOffsetPtg","bestStartIndex","bestEndIndex","missSimilarity","scrollPtg","locatedItemRelativeTop","compareItemTop","locatedItemIndex","itemElementHeights","similarity","abs","rawListScrollHandler","event","rawScrollTop","offsetPtg","virtualListScrollHandler","isInit","changedItemIndex","switchTo","diff","rawTop","dom","scrollTo","arg","findIndex","align","options","block","itemTop","max","min","then","indexItemHeight","itemBottom","itemMiddle","viewportHeight_1","renderChildren","list","map","originIndex","node","cloneElement","ele","refLongestItemIndex","renderLongestItem","createElement","overflow","opacity","onResize","overflowY","overflowAnchor","Fragment","offset","displayName"],"sources":["D:/Code/EchoGPT-frontend/node_modules/@arco-design/web-react/es/_class/VirtualList/index.js"],"sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport React, { useEffect, useImperativeHandle, useRef, useMemo, useState, } from 'react';\nimport { getValidScrollTop, getCompareItemRelativeTop, getItemAbsoluteTop, getItemRelativeTop, getNodeHeight, getRangeIndex, getScrollPercentage, GHOST_ITEM_KEY, getLongestItemIndex, getLocationItem, } from './utils/itemUtil';\nimport { raf, caf } from '../../_util/raf';\nimport { isNumber } from '../../_util/is';\nimport usePrevious from '../../_util/hooks/usePrevious';\nimport { findListDiffIndex, getIndexByStartLoc } from './utils/algorithmUtil';\nimport Filler from './Filler';\nimport useStateWithPromise from '../../_util/hooks/useStateWithPromise';\nimport useIsFirstRender from '../../_util/hooks/useIsFirstRender';\nimport useForceUpdate from '../../_util/hooks/useForceUpdate';\nimport ResizeObserver from '../../_util/resizeObserver';\nimport useIsomorphicLayoutEffect from '../../_util/hooks/useIsomorphicLayoutEffect';\n// height of the virtual element, used to calculate total height of the virtual list\nvar DEFAULT_VIRTUAL_ITEM_HEIGHT = 32;\nvar KEY_VIRTUAL_ITEM_HEIGHT = \"__virtual_item_height_\" + Math.random().toFixed(5).slice(2);\n// after collecting the real height of the first screen element, calculate the virtual ItemHeight to trigger list re-rendering\nvar useComputeVirtualItemHeight = function (refItemHeightMap) {\n    var forceUpdate = useForceUpdate();\n    var heightMap = refItemHeightMap.current;\n    useEffect(function () {\n        // virtual item height should be static as possible, otherwise it is easy to cause jitter\n        if (Object.keys(heightMap).length && !heightMap[KEY_VIRTUAL_ITEM_HEIGHT]) {\n            heightMap[KEY_VIRTUAL_ITEM_HEIGHT] = Object.entries(heightMap).reduce(function (sum, _a, currentIndex, array) {\n                var _b = __read(_a, 2), currentHeight = _b[1];\n                var nextSum = sum + currentHeight;\n                return currentIndex === array.length - 1 ? Math.round(nextSum / array.length) : nextSum;\n            }, 0);\n            forceUpdate();\n        }\n    }, [Object.keys(heightMap).length]);\n};\n// cache the constructed results of child nodes to avoid redrawing of child nodes caused by re-construction during drawing\nvar useCacheChildrenNodes = function (children) {\n    var refCacheMap = useRef({});\n    var refPrevChildren = useRef(children);\n    useEffect(function () {\n        refPrevChildren.current = children;\n    }, [children]);\n    // children change means state of parent component is updated, so clear cache\n    if (children !== refPrevChildren.current) {\n        refCacheMap.current = {};\n    }\n    return function (item, index, props) {\n        if (!refCacheMap.current.hasOwnProperty(index)) {\n            refCacheMap.current[index] = children(item, index, props);\n        }\n        return refCacheMap.current[index];\n    };\n};\nvar VirtualList = React.forwardRef(function (props, ref) {\n    var style = props.style, className = props.className, children = props.children, _a = props.data, data = _a === void 0 ? [] : _a, itemKey = props.itemKey, _b = props.threshold, threshold = _b === void 0 ? 100 : _b, _c = props.wrapper, WrapperTagName = _c === void 0 ? 'div' : _c, _d = props.height, propHeight = _d === void 0 ? '100%' : _d, _e = props.isStaticItemHeight, isStaticItemHeight = _e === void 0 ? true : _e, propItemHeight = props.itemHeight, measureLongestItem = props.measureLongestItem, scrollOptions = props.scrollOptions, onScroll = props.onScroll, _f = props.needFiller, needFiller = _f === void 0 ? true : _f, outerStyle = props.outerStyle, restProps = __rest(props, [\"style\", \"className\", \"children\", \"data\", \"itemKey\", \"threshold\", \"wrapper\", \"height\", \"isStaticItemHeight\", \"itemHeight\", \"measureLongestItem\", \"scrollOptions\", \"onScroll\", \"needFiller\", \"outerStyle\"]);\n    // Compatible with setting the height of the list through style.maxHeight\n    var styleListMaxHeight = (style && style.maxHeight) || propHeight;\n    var refItemHeightMap = useRef({});\n    var _g = __read(useState(200), 2), stateHeight = _g[0], setStateHeight = _g[1];\n    var renderChild = useCacheChildrenNodes(children);\n    useComputeVirtualItemHeight(refItemHeightMap);\n    // Elements with the same height, the height of the item is based on the first rendering\n    var itemCount = data.length;\n    var itemHeight = propItemHeight ||\n        refItemHeightMap.current[KEY_VIRTUAL_ITEM_HEIGHT] ||\n        DEFAULT_VIRTUAL_ITEM_HEIGHT;\n    var viewportHeight = isNumber(styleListMaxHeight) ? styleListMaxHeight : stateHeight;\n    var itemCountVisible = Math.ceil(viewportHeight / itemHeight);\n    var itemTotalHeight = itemHeight * itemCount;\n    var isVirtual = threshold !== null && itemCount >= threshold && itemTotalHeight > viewportHeight;\n    var refList = useRef(null);\n    var refRafId = useRef(null);\n    var refLockScroll = useRef(false);\n    var refIsVirtual = useRef(isVirtual);\n    // The paddingTop of the record scrolling list is used to correct the scrolling distance\n    var scrollListPadding = useMemo(function () {\n        if (refList.current) {\n            var getPadding = function (property) {\n                return +window.getComputedStyle(refList.current)[property].replace(/\\D/g, '');\n            };\n            return {\n                top: getPadding('paddingTop'),\n                bottom: getPadding('paddingBottom'),\n            };\n        }\n        return { top: 0, bottom: 0 };\n    }, [refList.current]);\n    var _h = __read(useStateWithPromise({\n        // measure status\n        status: 'NONE',\n        // render range info\n        startIndex: 0,\n        endIndex: 0,\n        itemIndex: 0,\n        itemOffsetPtg: 0,\n        // scroll info\n        startItemTop: 0,\n        scrollTop: 0,\n    }), 2), state = _h[0], setState = _h[1];\n    var prevData = usePrevious(data) || [];\n    var isFirstRender = useIsFirstRender();\n    var getItemKey = function (item, index) {\n        return typeof itemKey === 'function'\n            ? itemKey(item, index)\n            : typeof itemKey === 'string'\n                ? item[itemKey]\n                : item.key || index;\n    };\n    var getItemKeyByIndex = function (index, items) {\n        if (items === void 0) { items = data; }\n        if (index === items.length) {\n            return GHOST_ITEM_KEY;\n        }\n        var item = items[index];\n        return item !== undefined ? getItemKey(item, index) : null;\n    };\n    var getCachedItemHeight = function (key) {\n        return refItemHeightMap.current[key] || itemHeight;\n    };\n    var internalScrollTo = function (relativeScroll) {\n        var compareItemIndex = relativeScroll.itemIndex, compareItemRelativeTop = relativeScroll.relativeTop;\n        var _a = refList.current, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;\n        var originScrollTop = state.scrollTop;\n        var maxScrollTop = scrollHeight - clientHeight;\n        var bestSimilarity = Number.MAX_VALUE;\n        var bestScrollTop = null;\n        var bestItemIndex = null;\n        var bestItemOffsetPtg = null;\n        var bestStartIndex = null;\n        var bestEndIndex = null;\n        var missSimilarity = 0;\n        for (var i = 0; i < maxScrollTop; i++) {\n            var scrollTop = getIndexByStartLoc(0, maxScrollTop, originScrollTop, i);\n            var scrollPtg = getScrollPercentage({ scrollTop: scrollTop, scrollHeight: scrollHeight, clientHeight: clientHeight });\n            var _b = getRangeIndex(scrollPtg, itemCount, itemCountVisible), itemIndex = _b.itemIndex, itemOffsetPtg = _b.itemOffsetPtg, startIndex = _b.startIndex, endIndex = _b.endIndex;\n            if (startIndex <= compareItemIndex && compareItemIndex <= endIndex) {\n                var locatedItemRelativeTop = getItemRelativeTop({\n                    itemHeight: getCachedItemHeight(getItemKeyByIndex(itemIndex)),\n                    itemOffsetPtg: itemOffsetPtg,\n                    clientHeight: clientHeight,\n                    scrollPtg: scrollPtg,\n                });\n                var compareItemTop = getCompareItemRelativeTop({\n                    locatedItemRelativeTop: locatedItemRelativeTop,\n                    locatedItemIndex: itemIndex,\n                    compareItemIndex: compareItemIndex,\n                    startIndex: startIndex,\n                    endIndex: endIndex,\n                    itemHeight: itemHeight,\n                    getItemKey: getItemKeyByIndex,\n                    itemElementHeights: refItemHeightMap.current,\n                });\n                var similarity = Math.abs(compareItemTop - compareItemRelativeTop);\n                if (similarity < bestSimilarity) {\n                    bestSimilarity = similarity;\n                    bestScrollTop = scrollTop;\n                    bestItemIndex = itemIndex;\n                    bestItemOffsetPtg = itemOffsetPtg;\n                    bestStartIndex = startIndex;\n                    bestEndIndex = endIndex;\n                    missSimilarity = 0;\n                }\n                else {\n                    missSimilarity += 1;\n                }\n            }\n            if (missSimilarity > 10) {\n                break;\n            }\n        }\n        if (bestScrollTop !== null) {\n            refLockScroll.current = true;\n            refList.current.scrollTop = bestScrollTop;\n            setState(__assign(__assign({}, state), { status: 'MEASURE_START', scrollTop: bestScrollTop, itemIndex: bestItemIndex, itemOffsetPtg: bestItemOffsetPtg, startIndex: bestStartIndex, endIndex: bestEndIndex }));\n        }\n        refRafId.current = raf(function () {\n            refLockScroll.current = false;\n        });\n    };\n    // Record the current element position when the real list is scrolled, and ensure that the position is correct after switching to the virtual list\n    var rawListScrollHandler = function (event) {\n        var _a = refList.current, rawScrollTop = _a.scrollTop, clientHeight = _a.clientHeight, scrollHeight = _a.scrollHeight;\n        var scrollTop = getValidScrollTop(rawScrollTop, scrollHeight - clientHeight);\n        var scrollPtg = getScrollPercentage({\n            scrollTop: scrollTop,\n            clientHeight: clientHeight,\n            scrollHeight: scrollHeight,\n        });\n        var _b = getLocationItem(scrollPtg, itemCount), index = _b.index, offsetPtg = _b.offsetPtg;\n        setState(__assign(__assign({}, state), { scrollTop: scrollTop, itemIndex: index, itemOffsetPtg: offsetPtg }));\n        event && onScroll && onScroll(event);\n    };\n    // Modify the state and recalculate the position in the next render\n    var virtualListScrollHandler = function (event, isInit) {\n        if (isInit === void 0) { isInit = false; }\n        // Do NOT use refList.current.scrollHeight\n        // We should use Filler's height as total scroll height\n        // Filler's translate style may make refList.current.scrollHeight larger than Filler's height\n        var scrollHeight = itemTotalHeight;\n        var _a = refList.current, rawScrollTop = _a.scrollTop, clientHeight = _a.clientHeight;\n        var scrollTop = getValidScrollTop(rawScrollTop, scrollHeight - clientHeight);\n        // Prevent jitter\n        if (!isInit && (scrollTop === state.scrollTop || refLockScroll.current)) {\n            return;\n        }\n        var scrollPtg = getScrollPercentage({\n            scrollTop: scrollTop,\n            clientHeight: clientHeight,\n            scrollHeight: scrollHeight,\n        });\n        var _b = getRangeIndex(scrollPtg, itemCount, itemCountVisible), itemIndex = _b.itemIndex, itemOffsetPtg = _b.itemOffsetPtg, startIndex = _b.startIndex, endIndex = _b.endIndex;\n        setState(__assign(__assign({}, state), { scrollTop: scrollTop, itemIndex: itemIndex, itemOffsetPtg: itemOffsetPtg, startIndex: startIndex, endIndex: endIndex, status: 'MEASURE_START' }));\n        event && onScroll && onScroll(event);\n    };\n    useEffect(function () {\n        return function () {\n            refRafId.current && caf(refRafId.current);\n        };\n    }, []);\n    // rerender when the number of visible elements changes\n    useEffect(function () {\n        if (refList.current) {\n            if (isFirstRender) {\n                refList.current.scrollTop = 0;\n            }\n            virtualListScrollHandler(null, true);\n        }\n    }, [itemCountVisible]);\n    // Handle additions and deletions of list items or switching the virtual state\n    useEffect(function () {\n        var changedItemIndex = null;\n        var switchTo = refIsVirtual.current !== isVirtual ? (isVirtual ? 'virtual' : 'raw') : '';\n        refIsVirtual.current = isVirtual;\n        if (viewportHeight && prevData.length !== data.length) {\n            var diff = findListDiffIndex(prevData, data, getItemKey);\n            changedItemIndex = diff ? diff.index : null;\n        }\n        // No need to correct the position when the number of elements in the real list changes\n        if (switchTo || (isVirtual && changedItemIndex)) {\n            var clientHeight = refList.current.clientHeight;\n            var locatedItemRelativeTop = getItemRelativeTop({\n                itemHeight: getCachedItemHeight(getItemKeyByIndex(state.itemIndex, prevData)),\n                itemOffsetPtg: state.itemOffsetPtg,\n                scrollPtg: getScrollPercentage({\n                    scrollTop: state.scrollTop,\n                    scrollHeight: prevData.length * itemHeight,\n                    clientHeight: clientHeight,\n                }),\n                clientHeight: clientHeight,\n            });\n            if (switchTo === 'raw') {\n                var rawTop = locatedItemRelativeTop;\n                for (var index = 0; index < state.itemIndex; index++) {\n                    rawTop -= getCachedItemHeight(getItemKeyByIndex(index));\n                }\n                refList.current.scrollTop = -rawTop;\n                refLockScroll.current = true;\n                refRafId.current = raf(function () {\n                    refLockScroll.current = false;\n                });\n            }\n            else {\n                internalScrollTo({\n                    itemIndex: state.itemIndex,\n                    relativeTop: locatedItemRelativeTop,\n                });\n            }\n        }\n    }, [data, isVirtual]);\n    useIsomorphicLayoutEffect(function () {\n        if (state.status === 'MEASURE_START') {\n            var _a = refList.current, scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;\n            var scrollPtg = getScrollPercentage({\n                scrollTop: scrollTop,\n                scrollHeight: scrollHeight,\n                clientHeight: clientHeight,\n            });\n            // Calculate the top value of the first rendering element\n            var startItemTop = getItemAbsoluteTop({\n                scrollPtg: scrollPtg,\n                clientHeight: clientHeight,\n                scrollTop: scrollTop - (scrollListPadding.top + scrollListPadding.bottom) * scrollPtg,\n                itemHeight: getCachedItemHeight(getItemKeyByIndex(state.itemIndex)),\n                itemOffsetPtg: state.itemOffsetPtg,\n            });\n            for (var index = state.itemIndex - 1; index >= state.startIndex; index--) {\n                startItemTop -= getCachedItemHeight(getItemKeyByIndex(index));\n            }\n            setState(__assign(__assign({}, state), { startItemTop: startItemTop, status: 'MEASURE_DONE' }));\n        }\n    }, [state]);\n    useImperativeHandle(ref, function () { return ({\n        dom: refList.current,\n        // Scroll to a certain height or an element\n        scrollTo: function (arg) {\n            refRafId.current && caf(refRafId.current);\n            refRafId.current = raf(function () {\n                var _a;\n                if (typeof arg === 'number') {\n                    refList.current.scrollTop = arg;\n                    return;\n                }\n                var index = 'index' in arg\n                    ? arg.index\n                    : 'key' in arg\n                        ? data.findIndex(function (item, index) { return getItemKey(item, index) === arg.key; })\n                        : 0;\n                var item = data[index];\n                if (!item) {\n                    return;\n                }\n                var align = typeof arg === 'object' && ((_a = arg.options) === null || _a === void 0 ? void 0 : _a.block)\n                    ? arg.options.block\n                    : (scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.block) || 'nearest';\n                var _b = refList.current, clientHeight = _b.clientHeight, scrollTop = _b.scrollTop;\n                if (isVirtual && !isStaticItemHeight) {\n                    if (align === 'nearest') {\n                        var itemIndex = state.itemIndex, itemOffsetPtg = state.itemOffsetPtg;\n                        if (Math.abs(itemIndex - index) < itemCountVisible) {\n                            var itemTop = getItemRelativeTop({\n                                itemHeight: getCachedItemHeight(getItemKeyByIndex(itemIndex)),\n                                itemOffsetPtg: itemOffsetPtg,\n                                clientHeight: clientHeight,\n                                scrollPtg: getScrollPercentage(refList.current),\n                            });\n                            if (index < itemIndex) {\n                                for (var i = index; i < itemIndex; i++) {\n                                    itemTop -= getCachedItemHeight(getItemKeyByIndex(i));\n                                }\n                            }\n                            else {\n                                for (var i = itemIndex; i < index; i++) {\n                                    itemTop += getCachedItemHeight(getItemKeyByIndex(i));\n                                }\n                            }\n                            // When the target element is within the field of view, exit directly\n                            if (itemTop < 0 || itemTop > clientHeight) {\n                                align = itemTop < 0 ? 'start' : 'end';\n                            }\n                            else {\n                                return;\n                            }\n                        }\n                        else {\n                            align = index < itemIndex ? 'start' : 'end';\n                        }\n                    }\n                    setState(__assign(__assign({}, state), { startIndex: Math.max(0, index - itemCountVisible), endIndex: Math.min(itemCount - 1, index + itemCountVisible) })).then(function () {\n                        var itemHeight = getCachedItemHeight(getItemKey(item, index));\n                        internalScrollTo({\n                            itemIndex: index,\n                            relativeTop: align === 'start'\n                                ? 0\n                                : (clientHeight - itemHeight) / (align === 'center' ? 2 : 1),\n                        });\n                    });\n                }\n                else {\n                    var indexItemHeight = getCachedItemHeight(getItemKeyByIndex(index));\n                    var itemTop = 0;\n                    for (var i = 0; i < index; i++) {\n                        itemTop += getCachedItemHeight(getItemKeyByIndex(i));\n                    }\n                    var itemBottom = itemTop + indexItemHeight;\n                    var itemMiddle = itemTop + indexItemHeight / 2;\n                    // If item is visible, skip scrolling\n                    if (itemMiddle > scrollTop && itemMiddle < clientHeight + scrollTop) {\n                        return;\n                    }\n                    if (align === 'nearest') {\n                        if (itemTop < scrollTop) {\n                            align = 'start';\n                        }\n                        else if (itemBottom > scrollTop + clientHeight) {\n                            align = 'end';\n                        }\n                    }\n                    var viewportHeight_1 = clientHeight - indexItemHeight;\n                    refList.current.scrollTop =\n                        itemTop - (align === 'start' ? 0 : viewportHeight_1 / (align === 'center' ? 2 : 1));\n                }\n            });\n        },\n    }); }, [data, itemHeight, state]);\n    var renderChildren = function (list, startIndex) {\n        return list.map(function (item, index) {\n            var originIndex = startIndex + index;\n            var node = renderChild(item, originIndex, {\n                style: {},\n            });\n            var key = getItemKey(item, originIndex);\n            return React.cloneElement(node, {\n                key: key,\n                ref: function (ele) {\n                    var heightMap = refItemHeightMap.current;\n                    // Minimize the measurement of element height as much as possible to avoid frequent triggering of browser reflow\n                    // Method getNodeHeight get the clientHeight from the DOM referred by React ref. If result is wrong, check the ref of this element\n                    if (ele &&\n                        state.status === 'MEASURE_START' &&\n                        (!isStaticItemHeight || heightMap[key] === undefined)) {\n                        if (isStaticItemHeight) {\n                            if (!heightMap[KEY_VIRTUAL_ITEM_HEIGHT]) {\n                                heightMap[KEY_VIRTUAL_ITEM_HEIGHT] = getNodeHeight(ele, true);\n                            }\n                            heightMap[key] = heightMap[KEY_VIRTUAL_ITEM_HEIGHT];\n                        }\n                        else {\n                            heightMap[key] = getNodeHeight(ele, true);\n                        }\n                    }\n                },\n            });\n        });\n    };\n    // Render the widest element to provide the maximum width of the container initially\n    var refLongestItemIndex = useRef(null);\n    // Don't add `renderChild` to the array dependency, it will change every time when rerender\n    useEffect(function () {\n        refLongestItemIndex.current = null;\n    }, [data]);\n    var renderLongestItem = function () {\n        if (measureLongestItem) {\n            var index = refLongestItemIndex.current === null\n                ? getLongestItemIndex(data)\n                : refLongestItemIndex.current;\n            var item = data[index];\n            refLongestItemIndex.current = index;\n            return item ? (React.createElement(\"div\", { style: { height: 1, overflow: 'hidden', opacity: 0 } }, renderChild(item, index, { style: {} }))) : null;\n        }\n        return null;\n    };\n    return (React.createElement(ResizeObserver, { onResize: function () {\n            if (refList.current && !isNumber(styleListMaxHeight)) {\n                var clientHeight = refList.current.clientHeight;\n                setStateHeight(clientHeight);\n            }\n        } },\n        React.createElement(WrapperTagName, __assign({ ref: refList, style: __assign(__assign({ overflowY: 'auto', overflowAnchor: 'none' }, style), { maxHeight: styleListMaxHeight }), className: className, onScroll: isVirtual ? virtualListScrollHandler : rawListScrollHandler }, restProps), isVirtual ? (React.createElement(React.Fragment, null,\n            React.createElement(Filler, { height: itemTotalHeight, offset: state.status === 'MEASURE_DONE' ? state.startItemTop : 0, outerStyle: outerStyle }, renderChildren(data.slice(state.startIndex, state.endIndex + 1), state.startIndex)),\n            renderLongestItem())) : needFiller ? (React.createElement(Filler, { height: viewportHeight }, renderChildren(data, 0))) : (renderChildren(data, 0)))));\n});\nVirtualList.displayName = 'VirtualList';\nexport default VirtualList;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}