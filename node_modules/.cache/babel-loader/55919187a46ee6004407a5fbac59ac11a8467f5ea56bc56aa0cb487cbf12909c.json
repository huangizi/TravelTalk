{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\n/**\n * Judge whether a number is scientific notation\n */\nexport function isE(number) {\n  return !Number.isNaN(Number(number)) && String(number).includes('e');\n}\n/**\n * Judge whether BigInt is supported by current env\n */\nexport function supportBigInt() {\n  return typeof BigInt === 'function';\n}\n/**\n * Get precision of a number, include scientific notation like 1e-10\n */\nexport function getNumberPrecision(number) {\n  var numStr = String(number);\n  if (isE(number)) {\n    var precision_1 = Number(numStr.slice(numStr.indexOf('e-') + 2));\n    numStr.replace(/\\.(\\d+)/, function (_, $1) {\n      precision_1 += $1.length;\n      return _;\n    });\n    return precision_1;\n  }\n  return numStr.includes('.') && validateNumber(numStr) ? numStr.length - numStr.indexOf('.') - 1 : 0;\n}\n/**\n * Convert number to non-scientific notation\n */\nexport function toSafeString(number) {\n  var nativeNumberStr = String(number);\n  if (isE(number)) {\n    if (number < Number.MIN_SAFE_INTEGER) {\n      return supportBigInt() ? BigInt(number).toString() : Number.MIN_SAFE_INTEGER.toString();\n    }\n    if (number > Number.MAX_SAFE_INTEGER) {\n      return supportBigInt() ? BigInt(number).toString() : Number.MAX_SAFE_INTEGER.toString();\n    }\n    // This may lose precision, but foFixed must accept argument in the range 0-100\n    var precision = getNumberPrecision(nativeNumberStr);\n    nativeNumberStr = Number(number).toFixed(Math.min(100, precision));\n  }\n  return trimNumber(nativeNumberStr).fullStr;\n}\n/**\n * Judge whether a number is valid\n */\nexport function validateNumber(num) {\n  if (typeof num === 'number') {\n    return !Number.isNaN(num);\n  }\n  if (!num) {\n    return false;\n  }\n  return (\n    // 1.1\n    /^\\s*-?\\d+(\\.\\d+)?\\s*$/.test(num) ||\n    // 1.\n    /^\\s*-?\\d+\\.\\s*$/.test(num) ||\n    // .1\n    /^\\s*-?\\.\\d+\\s*$/.test(num)\n  );\n}\nexport function trimNumber(numStr) {\n  var str = numStr.trim();\n  var negative = false;\n  str = str\n  // Remove negative-label(-) at head.\n  .replace(/^-/, function () {\n    negative = true;\n    return '';\n  })\n  // Remove useless 0 at decimal end. `1.00100` => `1.001`\n  .replace(/(\\.\\d*[^0])0*$/, '$1')\n  // Remove useless decimal.\n  .replace(/\\.0*$/, '')\n  // Remove useless 0 at head.\n  .replace(/^0+/, '')\n  // Add 0 before empty dot. `.1` => `0.1`\n  .replace(/^\\./, '0.');\n  var trimStr = str || '0';\n  var _a = __read(trimStr.split('.'), 2),\n    _b = _a[0],\n    integerStr = _b === void 0 ? '0' : _b,\n    _c = _a[1],\n    decimalStr = _c === void 0 ? '0' : _c;\n  if (integerStr === '0' && decimalStr === '0') {\n    negative = false;\n  }\n  var negativeStr = negative ? '-' : '';\n  return {\n    negative: negative,\n    negativeStr: negativeStr,\n    trimStr: trimStr,\n    integerStr: integerStr,\n    decimalStr: decimalStr,\n    fullStr: \"\" + negativeStr + trimStr\n  };\n}","map":{"version":3,"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","isE","number","Number","isNaN","String","includes","supportBigInt","BigInt","getNumberPrecision","numStr","precision_1","slice","indexOf","replace","_","$1","length","validateNumber","toSafeString","nativeNumberStr","MIN_SAFE_INTEGER","toString","MAX_SAFE_INTEGER","precision","toFixed","Math","min","trimNumber","fullStr","num","test","str","trim","negative","trimStr","_a","split","_b","integerStr","_c","decimalStr","negativeStr"],"sources":["D:/Code/EchoGPT-frontend/node_modules/@arco-design/web-react/es/InputNumber/utils.js"],"sourcesContent":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n/**\n * Judge whether a number is scientific notation\n */\nexport function isE(number) {\n    return !Number.isNaN(Number(number)) && String(number).includes('e');\n}\n/**\n * Judge whether BigInt is supported by current env\n */\nexport function supportBigInt() {\n    return typeof BigInt === 'function';\n}\n/**\n * Get precision of a number, include scientific notation like 1e-10\n */\nexport function getNumberPrecision(number) {\n    var numStr = String(number);\n    if (isE(number)) {\n        var precision_1 = Number(numStr.slice(numStr.indexOf('e-') + 2));\n        numStr.replace(/\\.(\\d+)/, function (_, $1) {\n            precision_1 += $1.length;\n            return _;\n        });\n        return precision_1;\n    }\n    return numStr.includes('.') && validateNumber(numStr)\n        ? numStr.length - numStr.indexOf('.') - 1\n        : 0;\n}\n/**\n * Convert number to non-scientific notation\n */\nexport function toSafeString(number) {\n    var nativeNumberStr = String(number);\n    if (isE(number)) {\n        if (number < Number.MIN_SAFE_INTEGER) {\n            return supportBigInt() ? BigInt(number).toString() : Number.MIN_SAFE_INTEGER.toString();\n        }\n        if (number > Number.MAX_SAFE_INTEGER) {\n            return supportBigInt() ? BigInt(number).toString() : Number.MAX_SAFE_INTEGER.toString();\n        }\n        // This may lose precision, but foFixed must accept argument in the range 0-100\n        var precision = getNumberPrecision(nativeNumberStr);\n        nativeNumberStr = Number(number).toFixed(Math.min(100, precision));\n    }\n    return trimNumber(nativeNumberStr).fullStr;\n}\n/**\n * Judge whether a number is valid\n */\nexport function validateNumber(num) {\n    if (typeof num === 'number') {\n        return !Number.isNaN(num);\n    }\n    if (!num) {\n        return false;\n    }\n    return (\n    // 1.1\n    /^\\s*-?\\d+(\\.\\d+)?\\s*$/.test(num) ||\n        // 1.\n        /^\\s*-?\\d+\\.\\s*$/.test(num) ||\n        // .1\n        /^\\s*-?\\.\\d+\\s*$/.test(num));\n}\nexport function trimNumber(numStr) {\n    var str = numStr.trim();\n    var negative = false;\n    str = str\n        // Remove negative-label(-) at head.\n        .replace(/^-/, function () {\n        negative = true;\n        return '';\n    })\n        // Remove useless 0 at decimal end. `1.00100` => `1.001`\n        .replace(/(\\.\\d*[^0])0*$/, '$1')\n        // Remove useless decimal.\n        .replace(/\\.0*$/, '')\n        // Remove useless 0 at head.\n        .replace(/^0+/, '')\n        // Add 0 before empty dot. `.1` => `0.1`\n        .replace(/^\\./, '0.');\n    var trimStr = str || '0';\n    var _a = __read(trimStr.split('.'), 2), _b = _a[0], integerStr = _b === void 0 ? '0' : _b, _c = _a[1], decimalStr = _c === void 0 ? '0' : _c;\n    if (integerStr === '0' && decimalStr === '0') {\n        negative = false;\n    }\n    var negativeStr = negative ? '-' : '';\n    return {\n        negative: negative,\n        negativeStr: negativeStr,\n        trimStr: trimStr,\n        integerStr: integerStr,\n        decimalStr: decimalStr,\n        fullStr: \"\" + negativeStr + trimStr,\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}