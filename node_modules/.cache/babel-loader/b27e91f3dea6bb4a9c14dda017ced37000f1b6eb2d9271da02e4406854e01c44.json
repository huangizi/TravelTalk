{"ast":null,"code":"export function resolveItemData(cols, _a) {\n  var span = _a.span,\n    offset = _a.offset,\n    suffix = _a.suffix;\n  var originSpan = span !== null && span !== void 0 ? span : 1;\n  var originOffset = offset !== null && offset !== void 0 ? offset : 0;\n  var minOffset = Math.min(originOffset, cols);\n  var minSpan = Math.min(minOffset > 0 ? originSpan + originOffset : originSpan, cols);\n  return {\n    span: minSpan,\n    offset: minOffset,\n    suffix: suffix\n  };\n}\nexport function setItemVisible(_a) {\n  var cols = _a.cols,\n    collapsed = _a.collapsed,\n    collapsedRows = _a.collapsedRows,\n    itemDataList = _a.itemDataList;\n  var overflow = false;\n  var displayIndexList = [];\n  function isOverflow(span) {\n    return Math.ceil(span / cols) > collapsedRows;\n  }\n  if (collapsed) {\n    var spanSum = 0;\n    for (var i = 0; i < itemDataList.length; i++) {\n      if (itemDataList[i].suffix) {\n        spanSum += itemDataList[i].span;\n        displayIndexList.push(i);\n      }\n    }\n    if (!isOverflow(spanSum)) {\n      var current = 0;\n      while (current < itemDataList.length) {\n        var item = itemDataList[current];\n        if (!item.suffix) {\n          spanSum += item.span;\n          if (isOverflow(spanSum)) {\n            break;\n          }\n          displayIndexList.push(current);\n        }\n        current++;\n      }\n    }\n    overflow = itemDataList.some(function (item, index) {\n      return !item.suffix && !displayIndexList.includes(index);\n    });\n  } else {\n    displayIndexList = itemDataList.map(function (_, index) {\n      return index;\n    });\n  }\n  return {\n    overflow: overflow,\n    displayIndexList: displayIndexList\n  };\n}","map":{"version":3,"names":["resolveItemData","cols","_a","span","offset","suffix","originSpan","originOffset","minOffset","Math","min","minSpan","setItemVisible","collapsed","collapsedRows","itemDataList","overflow","displayIndexList","isOverflow","ceil","spanSum","i","length","push","current","item","some","index","includes","map","_"],"sources":["D:/Code/ceo-copilot-frontend/node_modules/@arco-design/web-react/es/Grid/utils.js"],"sourcesContent":["export function resolveItemData(cols, _a) {\n    var span = _a.span, offset = _a.offset, suffix = _a.suffix;\n    var originSpan = span !== null && span !== void 0 ? span : 1;\n    var originOffset = offset !== null && offset !== void 0 ? offset : 0;\n    var minOffset = Math.min(originOffset, cols);\n    var minSpan = Math.min(minOffset > 0 ? originSpan + originOffset : originSpan, cols);\n    return {\n        span: minSpan,\n        offset: minOffset,\n        suffix: suffix,\n    };\n}\nexport function setItemVisible(_a) {\n    var cols = _a.cols, collapsed = _a.collapsed, collapsedRows = _a.collapsedRows, itemDataList = _a.itemDataList;\n    var overflow = false;\n    var displayIndexList = [];\n    function isOverflow(span) {\n        return Math.ceil(span / cols) > collapsedRows;\n    }\n    if (collapsed) {\n        var spanSum = 0;\n        for (var i = 0; i < itemDataList.length; i++) {\n            if (itemDataList[i].suffix) {\n                spanSum += itemDataList[i].span;\n                displayIndexList.push(i);\n            }\n        }\n        if (!isOverflow(spanSum)) {\n            var current = 0;\n            while (current < itemDataList.length) {\n                var item = itemDataList[current];\n                if (!item.suffix) {\n                    spanSum += item.span;\n                    if (isOverflow(spanSum)) {\n                        break;\n                    }\n                    displayIndexList.push(current);\n                }\n                current++;\n            }\n        }\n        overflow = itemDataList.some(function (item, index) { return !item.suffix && !displayIndexList.includes(index); });\n    }\n    else {\n        displayIndexList = itemDataList.map(function (_, index) { return index; });\n    }\n    return {\n        overflow: overflow,\n        displayIndexList: displayIndexList,\n    };\n}\n"],"mappings":"AAAA,OAAO,SAASA,eAAeA,CAACC,IAAI,EAAEC,EAAE,EAAE;EACtC,IAAIC,IAAI,GAAGD,EAAE,CAACC,IAAI;IAAEC,MAAM,GAAGF,EAAE,CAACE,MAAM;IAAEC,MAAM,GAAGH,EAAE,CAACG,MAAM;EAC1D,IAAIC,UAAU,GAAGH,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAGA,IAAI,GAAG,CAAC;EAC5D,IAAII,YAAY,GAAGH,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAGA,MAAM,GAAG,CAAC;EACpE,IAAII,SAAS,GAAGC,IAAI,CAACC,GAAG,CAACH,YAAY,EAAEN,IAAI,CAAC;EAC5C,IAAIU,OAAO,GAAGF,IAAI,CAACC,GAAG,CAACF,SAAS,GAAG,CAAC,GAAGF,UAAU,GAAGC,YAAY,GAAGD,UAAU,EAAEL,IAAI,CAAC;EACpF,OAAO;IACHE,IAAI,EAAEQ,OAAO;IACbP,MAAM,EAAEI,SAAS;IACjBH,MAAM,EAAEA;EACZ,CAAC;AACL;AACA,OAAO,SAASO,cAAcA,CAACV,EAAE,EAAE;EAC/B,IAAID,IAAI,GAAGC,EAAE,CAACD,IAAI;IAAEY,SAAS,GAAGX,EAAE,CAACW,SAAS;IAAEC,aAAa,GAAGZ,EAAE,CAACY,aAAa;IAAEC,YAAY,GAAGb,EAAE,CAACa,YAAY;EAC9G,IAAIC,QAAQ,GAAG,KAAK;EACpB,IAAIC,gBAAgB,GAAG,EAAE;EACzB,SAASC,UAAUA,CAACf,IAAI,EAAE;IACtB,OAAOM,IAAI,CAACU,IAAI,CAAChB,IAAI,GAAGF,IAAI,CAAC,GAAGa,aAAa;EACjD;EACA,IAAID,SAAS,EAAE;IACX,IAAIO,OAAO,GAAG,CAAC;IACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,YAAY,CAACO,MAAM,EAAED,CAAC,EAAE,EAAE;MAC1C,IAAIN,YAAY,CAACM,CAAC,CAAC,CAAChB,MAAM,EAAE;QACxBe,OAAO,IAAIL,YAAY,CAACM,CAAC,CAAC,CAAClB,IAAI;QAC/Bc,gBAAgB,CAACM,IAAI,CAACF,CAAC,CAAC;MAC5B;IACJ;IACA,IAAI,CAACH,UAAU,CAACE,OAAO,CAAC,EAAE;MACtB,IAAII,OAAO,GAAG,CAAC;MACf,OAAOA,OAAO,GAAGT,YAAY,CAACO,MAAM,EAAE;QAClC,IAAIG,IAAI,GAAGV,YAAY,CAACS,OAAO,CAAC;QAChC,IAAI,CAACC,IAAI,CAACpB,MAAM,EAAE;UACde,OAAO,IAAIK,IAAI,CAACtB,IAAI;UACpB,IAAIe,UAAU,CAACE,OAAO,CAAC,EAAE;YACrB;UACJ;UACAH,gBAAgB,CAACM,IAAI,CAACC,OAAO,CAAC;QAClC;QACAA,OAAO,EAAE;MACb;IACJ;IACAR,QAAQ,GAAGD,YAAY,CAACW,IAAI,CAAC,UAAUD,IAAI,EAAEE,KAAK,EAAE;MAAE,OAAO,CAACF,IAAI,CAACpB,MAAM,IAAI,CAACY,gBAAgB,CAACW,QAAQ,CAACD,KAAK,CAAC;IAAE,CAAC,CAAC;EACtH,CAAC,MACI;IACDV,gBAAgB,GAAGF,YAAY,CAACc,GAAG,CAAC,UAAUC,CAAC,EAAEH,KAAK,EAAE;MAAE,OAAOA,KAAK;IAAE,CAAC,CAAC;EAC9E;EACA,OAAO;IACHX,QAAQ,EAAEA,QAAQ;IAClBC,gBAAgB,EAAEA;EACtB,CAAC;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}